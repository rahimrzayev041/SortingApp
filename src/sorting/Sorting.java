// Name: Rahim
// Surname: Rzayev
/* Description: An app is developed for sorting numbers using selection, bubble, insertion, and quick sorting methods. 
Sorting can be done in ascending or descending order. 
Users can print the result from the textfield and the textfield after sorting.*/



package sorting;

// imports
import java.util.Random;//The java.util.Random class instance is used to generate a stream of pseudorandom numbers.Following are the important points about Random âˆ’ The class uses a 48-bit seed, which is modified using a linear congruential formula.
import javax.swing.JOptionPane;//javax.swing.JOptionPane. The Java API class javax. swing. JOptionPane has facilities for creating a dialog box that can appear on the computer's desktop to request input from or display messages to the user.
import java.text.DecimalFormat;//You can use the DecimalFormat class to format decimal numbers into locale-specific strings. This class allows you to control the display of leading and trailing zeros, prefixes and suffixes, grouping (thousands) separators, and the decimal separator.
import javax.swing.JFrame;

public class Sorting extends javax.swing.JFrame {
    // declare imports
    Random r = new Random();//his gives a random integer
    DecimalFormat wf = new DecimalFormat("#,###,###,###,##0");//DecimalFormat is a concrete subclass of NumberFormat that formats decimal numbers. It has a variety of features designed to make it possible to parse and format numbers
    // declare global variables
        // loop counters
    static int selectionC = 0;//When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object. 
    static int bubbleC = 0;//When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object.
    static int insertionC = 0;//When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object.
    static int quickC = 0;//When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object.
    /**
     * Creates new form SortingEfficiencyAss
     */
    public Sorting() {
        initComponents();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        grpSortNum = new javax.swing.ButtonGroup();
        grpSortOrder = new javax.swing.ButtonGroup();
        lblTitle = new javax.swing.JLabel();
        lblOriginal = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtAOriginal = new javax.swing.JTextArea();
        lblSorted = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtASorted = new javax.swing.JTextArea();
        lblResults = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtAResults = new javax.swing.JTextArea();
        jPanel1 = new javax.swing.JPanel();
        btnSort = new javax.swing.JButton();
        print = new javax.swing.JButton();
        print1 = new javax.swing.JButton();
        reset = new javax.swing.JButton();
        exit = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        lblSortOrder = new javax.swing.JLabel();
        rdoAscending = new javax.swing.JRadioButton();
        rdoDescending = new javax.swing.JRadioButton();
        jPanel3 = new javax.swing.JPanel();
        lblSortType = new javax.swing.JLabel();
        cboSortType = new javax.swing.JComboBox();
        jPanel4 = new javax.swing.JPanel();
        rdo5000 = new javax.swing.JRadioButton();
        rdo100 = new javax.swing.JRadioButton();
        rdo1000 = new javax.swing.JRadioButton();
        rdo10 = new javax.swing.JRadioButton();
        lblSortNum = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Sorting");
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        lblTitle.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        lblTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lblTitle.setText("Sorting ");
        getContentPane().add(lblTitle, new org.netbeans.lib.awtextra.AbsoluteConstraints(230, 10, 335, -1));

        lblOriginal.setText("Original Numbers:");
        getContentPane().add(lblOriginal, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 185, -1, -1));

        txtAOriginal.setEditable(false);
        txtAOriginal.setColumns(20);
        txtAOriginal.setRows(5);
        jScrollPane1.setViewportView(txtAOriginal);

        getContentPane().add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 205, 253, 284));

        lblSorted.setText("Sorted Numbers:");
        getContentPane().add(lblSorted, new org.netbeans.lib.awtextra.AbsoluteConstraints(281, 185, -1, -1));

        txtASorted.setEditable(false);
        txtASorted.setColumns(20);
        txtASorted.setRows(5);
        jScrollPane2.setViewportView(txtASorted);

        getContentPane().add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(281, 205, 253, 284));

        lblResults.setText("Sort Results:");
        getContentPane().add(lblResults, new org.netbeans.lib.awtextra.AbsoluteConstraints(552, 185, -1, -1));

        txtAResults.setEditable(false);
        txtAResults.setColumns(20);
        txtAResults.setRows(5);
        jScrollPane3.setViewportView(txtAResults);

        getContentPane().add(jScrollPane3, new org.netbeans.lib.awtextra.AbsoluteConstraints(552, 205, 298, 284));

        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 3));

        btnSort.setText("Sort");
        btnSort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnSortActionPerformed(evt);
            }
        });

        print.setText("Print sorted numbers");
        print.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                printActionPerformed(evt);
            }
        });

        print1.setText("Print sort results");
        print1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                print1ActionPerformed(evt);
            }
        });

        reset.setText("Reset");
        reset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetActionPerformed(evt);
            }
        });

        exit.setText("Exit");
        exit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(btnSort, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(print1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(reset, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 133, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(exit, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(print))
                .addGap(9, 9, 9))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(btnSort)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(print)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(print1, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(reset, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(exit, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(670, 10, 190, 160));

        jPanel2.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 3));

        lblSortOrder.setText("Sort Order:");

        grpSortOrder.add(rdoAscending);
        rdoAscending.setText("Ascending");

        grpSortOrder.add(rdoDescending);
        rdoDescending.setText("Descending");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(17, 17, 17)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(rdoAscending)
                            .addComponent(rdoDescending)))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(28, 28, 28)
                        .addComponent(lblSortOrder)))
                .addGap(0, 0, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblSortOrder)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 18, Short.MAX_VALUE)
                .addComponent(rdoAscending, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(rdoDescending, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        getContentPane().add(jPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(490, 40, 160, 110));

        jPanel3.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 3));

        lblSortType.setText("Display numbers sorted by:");

        cboSortType.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Selection Sort", "Bubble Sort", "Insertion Sort", "Quicksort" }));

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(lblSortType))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addGap(28, 28, 28)
                        .addComponent(cboSortType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblSortType)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(cboSortType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(43, Short.MAX_VALUE))
        );

        getContentPane().add(jPanel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(280, 40, 200, 110));

        jPanel4.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 3));

        grpSortNum.add(rdo5000);
        rdo5000.setText("5000");

        grpSortNum.add(rdo100);
        rdo100.setText("100");

        grpSortNum.add(rdo1000);
        rdo1000.setText("1000");

        grpSortNum.add(rdo10);
        rdo10.setText("10");
        rdo10.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rdo10ActionPerformed(evt);
            }
        });

        lblSortNum.setText("Amount of numbers to sort:");

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(rdo10)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(rdo100)
                .addGap(7, 7, 7)
                .addComponent(rdo1000)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(rdo5000)
                .addGap(7, 7, 7))
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addGap(32, 32, 32)
                .addComponent(lblSortNum)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel4Layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(lblSortNum)
                .addGap(18, 18, 18)
                .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(rdo5000)
                    .addGroup(jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(rdo1000)
                        .addComponent(rdo100)
                        .addComponent(rdo10, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(26, Short.MAX_VALUE))
        );

        getContentPane().add(jPanel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(6, 40, 270, 110));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnSortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnSortActionPerformed
        // declare needed variables
        boolean goSort = true;//The default numeric value of true is 1 and false is 0. We can use bool type variables or values true and false in mathematical expressions also.
        int amountNums = 0;//The int keyword is used to declare a variable 
        // retrieves the amount of rnd numbers to sort
        if(rdo10.isSelected()) {// These codes are for random10 an shows what will happen if user choose random10
            amountNums = 10;// it is for making amount of numbers 10
        } else if(rdo100.isSelected()) {
            amountNums = 100;//it is for making amount of numbers 100
        } else if(rdo1000.isSelected()) {
            amountNums = 1000;//it is for making amount of numbers 1000
        } else if(rdo5000.isSelected()) {
            amountNums = 5000;//it is for making amount of numbers 5000
        } else { // else (nothing isSelected, so don't run)
            goSort = false;//this code is for not sorting
        } // end if
        
        // only runs if a rdo btn for amount of rnd #s is selected
        if(goSort) {// This code is for sorting
            String originalDisplay = "";    //holds output for list of original #s
            int original[] = new int[amountNums];// generate an array with the specified amount of rnd numbers
            for (int i = 0; i < amountNums; i++) { //loads the array with rnd #s (-10,000 -> 10,000 inclusive)
                original[i] = r.nextInt(20001) - 10000;//for finding original [i] when user clicked the sort button
                originalDisplay += i + ":\t" + original[i] + "\n";// accumulate list of original numbers
            } // end for loop
            txtAOriginal.setText(originalDisplay);  //this code is for demonstrating
            
            
            int selectionCopy[] = new int[amountNums];// creates a copy of the original array for selection sort algorithm
            int bubbleCopy[] = new int[amountNums];// creates a copy of the original array for  bubble sort algorithm
            int insertionCopy[] = new int[amountNums];// creates a copy of the original array for insertion sort algorithm
            int quickCopy[] = new int[amountNums];// creates a copy of the original array for quick sort algorithm
            System.arraycopy(original, 0, selectionCopy, 0, amountNums);// copies the entire original array for selection sorting
            System.arraycopy(original, 0, bubbleCopy, 0, amountNums);// copies the entire original array for bubble sorting
            System.arraycopy(original, 0, insertionCopy, 0, amountNums);// copies the entire original array for insertion sorting
            System.arraycopy(original, 0, quickCopy, 0, amountNums);// copies the entire original array for quick sorting
            
            long selectionTimeStart, selectionTimeEnd, selectionTimeElapsed;// declare varaibles to track runtime of selection sorting algorithms
            long bubbleTimeStart, bubbleTimeEnd, bubbleTimeElapsed;// declare varaibles to track runtime of bubble sorting algorithms
            long insertionTimeStart, insertionTimeEnd, insertionTimeElapsed;// declare varaibles to track runtime of insertion sorting algorithms
            long quickTimeStart, quickTimeEnd, quickTimeElapsed;// declare varaibles to track runtime of quick sorting algorithms
            
            selectionC = 0;// this code is for making selectionC 0
            bubbleC = 0;// this code is for making bubbleC 0
            insertionC = 0;// this code is for making insertionC 0
            quickC = 0;// this code is for making quickC 0
            
            // check the order the array is to be sorted
            if(rdoAscending.isSelected()) {// this code is for showing if user selected ascending what whill happen
                // also tracks time algorithm took to sort
                selectionTimeStart = System.currentTimeMillis();//The java.lang.System.currentTimeMillis() method returns the current time in milliseconds
                selectionSortA(selectionCopy);  // selection sorts the copy of the original array
                selectionTimeEnd = System.currentTimeMillis();//currentTimeMillis() method returns the current time in milliseconds. The unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger.
                selectionTimeElapsed = selectionTimeEnd - selectionTimeStart;// these codes are for finding selectionTime time elapsed
                
                bubbleTimeStart = System.currentTimeMillis();//The java.lang.System.currentTimeMillis() method returns the current time in milliseconds
                bubbleSortA(bubbleCopy);  //bubble sorts the copy of the original array
                bubbleTimeEnd = System.currentTimeMillis();//currentTimeMillis() method returns the current time in milliseconds. The unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger.
                bubbleTimeElapsed = bubbleTimeEnd - bubbleTimeStart;// these codes are for finding bubble time elapsed
                
                insertionTimeStart = System.currentTimeMillis();//The java.lang.System.currentTimeMillis() method returns the current time in milliseconds
                insertionSortA(insertionCopy);  //insertion sorts the copy of the original array
                insertionTimeEnd = System.currentTimeMillis();//currentTimeMillis() method returns the current time in milliseconds. The unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger.
                insertionTimeElapsed = insertionTimeEnd - insertionTimeStart;// these codes are for finding insertion time elapsed
                
                quickTimeStart = System.currentTimeMillis();//The java.lang.System.currentTimeMillis() method returns the current time in milliseconds
                quicksortA(quickCopy, 0, quickCopy.length-1);  //quick sorts the copy of the original array
                quickTimeEnd = System.currentTimeMillis();//currentTimeMillis() method returns the current time in milliseconds. The unit of time of the return value is a millisecond, the granularity of the value depends on the underlying operating system and may be larger.
                quickTimeElapsed = quickTimeEnd - quickTimeStart;// these codes are for finding quick time elapsed
                
                txtASorted.setText(""); //this code is for deleting everything from txtASorted textfield
               
                displaySortedArray(selectionCopy, bubbleCopy, insertionCopy, quickCopy);//it is for displaying each sortings such as selection, bubble, insertion, quick
                displayResults(selectionTimeElapsed, bubbleTimeElapsed, insertionTimeElapsed, quickTimeElapsed);// displays loop counter and time results for each sorting algorithm
            
            } else if(rdoDescending.isSelected()){// These codes is for descending when user select descending for doing these operations
                // each algorithm sorts the copy of the original array
                // also tracks time algorithm took to sort
                selectionTimeStart = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in milliseconds for selectionTimeStart
                selectionSortD(selectionCopy);//selection sorts the copy of the original array
                selectionTimeEnd = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in milliseconds for selectionTimeEnd
                selectionTimeElapsed = selectionTimeEnd - selectionTimeStart;// these codes are for finding selectionTimeElapsed
                
                bubbleTimeStart = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in millisecondsfor bubbleTimeStart
                bubbleSortD(bubbleCopy);//bubble sorts the copy of the original array
                bubbleTimeEnd = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in milliseconds for bubbleTimeEnd
                bubbleTimeElapsed = bubbleTimeEnd - bubbleTimeStart;// these codes are for finding bubbleTimeElapsed
                
                insertionTimeStart = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in millisecondsfor insertionTimeStart
                insertionSortD(insertionCopy);//insertion sorts the copy of the original array
                insertionTimeEnd = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in milliseconds for insertionTimeEnd
                insertionTimeElapsed = insertionTimeEnd - insertionTimeStart;// these codes are for finding insertionTimeElapsed
                
                quickTimeStart = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in millisecondsfor quickTimeStart
                quicksortD(quickCopy, 0, quickCopy.length-1);//quick sort the copy of the original array
                quickTimeEnd = System.currentTimeMillis();//System.currentTimeMillis() method returns the current time in milliseconds for quickTimeEnd
                quickTimeElapsed = quickTimeEnd - quickTimeStart;// these codes are for finding quickTimeElapsed
                
                txtASorted.setText(""); //reset
                // display the sorted copy of the original array in the txtA that was sorted with the chosen sorting algorithm
                displaySortedArray(selectionCopy, bubbleCopy, insertionCopy, quickCopy);//it is for displaying each sortings such as selection, bubble, insertion, quick
                // displays loop counter and time results for each sorting algorithm
                displayResults(selectionTimeElapsed, bubbleTimeElapsed, insertionTimeElapsed, quickTimeElapsed);// displays loop counter and time results for each sorting algorithm
                
            } else {//These codes are for error messages and will appear if user did not choose the type of sorting
                txtASorted.setText("");     //this code is for deleting everything from txtASorted textfield
                txtAResults.setText("");     //this code is for deleting everything from txtAResults textfield
         
                JOptionPane.showMessageDialog(null, "A sorting order must be selected.\nPlease try again.","ERROR", JOptionPane.ERROR_MESSAGE); // This code is for showing error message
            } // end if
        } else {//These codes are for error messages and will appear if user did not choose an amount of numbers for sorting
            JOptionPane.showMessageDialog(null, "An amount of numbers to sort must be selected.\nPlease try again.", "ERROR", JOptionPane.ERROR_MESSAGE);// This code is for showing error message
        } // end if
    }//GEN-LAST:event_btnSortActionPerformed

    private void rdo10ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rdo10ActionPerformed
       // This button is for choosing amount of numbers that user is able to sort
    }//GEN-LAST:event_rdo10ActionPerformed

    private void printActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_printActionPerformed
      JFrame frame = new JFrame("Print");// these codes are written for creating new JFrame

        if (JOptionPane.showConfirmDialog(frame,"Do you want to print list?"," sorting",JOptionPane.YES_NO_OPTION)==JOptionPane.YES_NO_OPTION)//these code is used for showing option pane to user

        try{ /*
            try-catch block is used to handle exceptions in the program.
            If the program is not able to process the exception,
            it's thrown back to the JVM which terminates the program and prints the exception stack trace to the output stream
            */

            

            txtASorted.print();// this code is used for printing

        }catch (Exception e){//The finally block is used to provide statements that are executed regardless of whether any exceptions occur.
        }

     
    }//GEN-LAST:event_printActionPerformed

    private void resetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetActionPerformed
 txtASorted.setText("");     //this code is for deleting everything from txtASorted textfield
txtAResults.setText("");     //this code is for deleting everything from txtAResults textfield   
txtAOriginal.setText("");     //this code is for deleting everything from txtAOriginal textfield   
    }//GEN-LAST:event_resetActionPerformed

    private void print1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_print1ActionPerformed
       JFrame frame = new JFrame("Print");// these codes are written for creating new JFrame

        if (JOptionPane.showConfirmDialog(frame,"Do you want to print list?"," sorting",JOptionPane.YES_NO_OPTION)==JOptionPane.YES_NO_OPTION)//these code is used for showing option pane to user

        try{ /*
            try-catch block is used to handle exceptions in the program.
            If the program is not able to process the exception,
            it's thrown back to the JVM which terminates the program and prints the exception stack trace to the output stream
            */

            

            txtAResults.print();// this code is used for printing

        }catch (Exception e){//The finally block is used to provide statements that are executed regardless of whether any exceptions occur.
        }

     
    }//GEN-LAST:event_print1ActionPerformed

    private void exitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitActionPerformed
      System.exit(0);        // These codes are foor exitting from textfield
    }//GEN-LAST:event_exitActionPerformed
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Sorting.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Sorting.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Sorting.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Sorting.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Sorting().setVisible(true);
            } // end run()
        }); // end Runnable()
    } // end main
    /**
     * Displays loop counter and time results for each sorting algorithm
     * @param selectionTimeElapsed the time it took for the Selection Sort algorithm
     * @param bubbleTimeElapsed the time it took for the Bubble Sort algorithm
     * @param insertionTimeElapsed the time it took for the Insertion Sort algorithm
     * @param quickTimeElapsed the time it took for the Quicksort algorithm
     */
    public void displayResults(long selectionTimeElapsed, long bubbleTimeElapsed, long insertionTimeElapsed, long quickTimeElapsed) {

        String numLoops = "Number of times a loop was executed: ";// This code is for declareing numLoops 
        String time = "Number of milliseconds to complete sort: ";// This code is for declareing time 
        // display loop and time results for each sorting algorithm
        txtAResults.setText("Selection Sort:\n" + numLoops + wf.format(selectionC) + "\n" + time + selectionTimeElapsed + "\nBubble Sort:\n" + numLoops + wf.format(bubbleC) + "\n" + time + bubbleTimeElapsed + "\nInsertion Sort:\n" + numLoops + wf.format(insertionC) + "\n" + time + insertionTimeElapsed + "\nQuicksort:\n" + numLoops + wf.format(quickC) + "\n" + time + quickTimeElapsed);// this code is for showing result on the txtAResults textfield
    } // end displayResults()
    /**
     * Displays the copy of the original array sorted with the desired sorting algorithm
     * @param selectionCopy the copy of the original array to be sorted using Selection Sort
     * @param bubbleCopy the copy of the original array to be sorted using Bubble Sort
     * @param insertionCopy the copy of the original array to be sorted using Insertion Sort
     * @param quickCopy the copy of the original array to be sorted using Quicksort
     */
    public void displaySortedArray(int selectionCopy[], int bubbleCopy[], int insertionCopy[], int quickCopy[]) {
        String sortedDisplay = "";  //holds output for list of sorted #s
        // check which sort type is chosen to be displayed
        // and accumulate list of sorted #s for that sort algorithm
        if(cboSortType.getSelectedItem().equals("Selection Sort")) {// These codes are for selection sort
            for (int i = 0; i < selectionCopy.length; i++) {//A "For" Loop is used to repeat a specific block of code for Selection sort
                sortedDisplay += i + ":\t" + selectionCopy[i] + "\n";// These codes are for displaying selection sort
            } // end for loop
        } else if(cboSortType.getSelectedItem().equals("Bubble Sort")) {// These codes are for Bubble sort
            for (int i = 0; i < bubbleCopy.length; i++) {//A "For" Loop is used to repeat a specific block of code for Bubble sort
                sortedDisplay += i + ":\t" + bubbleCopy[i] + "\n";// These codes are for displaying selection sort
            } // end for loop
        } else if(cboSortType.getSelectedItem().equals("Insertion Sort")) {// These codes are for Insertion sort
            for (int i = 0; i < insertionCopy.length; i++) {//A "For" Loop is used to repeat a specific block of code for Insertion sort
                sortedDisplay += i + ":\t" + insertionCopy[i] + "\n";// These codes are for displaying selection sort
            } // end for loop
        } else if(cboSortType.getSelectedItem().equals("Quicksort")) {// These codes are for Quicksort sort
            for (int i = 0; i < quickCopy.length; i++) {//A "For" Loop is used to repeat a specific block of code for Quicksort sort
                sortedDisplay += i + ":\t" + quickCopy[i] + "\n";// These codes are for displaying selection sort
            } // end for loop
        } 
        txtASorted.setText(sortedDisplay);  //these codes are for displaying sorteddisplay on the txtASorted textfield
    }
    /**
     * Sorts an array of integers using Selection Sort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     */
    public static void selectionSortA(int nums[]) {
        int min;    //declare needed variables
        
        for (int i = 0; i < nums.length; i++) {//A "For" Loop is used to repeat a specific block of code for Selection sort
            min = i; // Assume first element is min
            // loop though entire array after above value
            for (int j = i+1; j < nums.length; j++) {//A "For" Loop is used to repeat a specific block of code for Selection sort
                if (nums[j] < nums[min]) {//these codes is used is nums[j] is smaller than nums[min]
                    min = j; //set index of new min
                }
                selectionC++; //accumulate loop counter
            } 
            if (min != i) { //It is used to decide whether a certain statement or block of statements will be executed or not i.e if a certain
                // swaps lower value on right with a higher value on left
                int temp = nums[i];     //sets as holder for 1st level value
                nums[i] = nums[min];    //sets min value in array back a position
                nums[min] = temp;       //sets new min
            } 
        } 
    } 
    /**
     * Sorts an array of integers using Selection Sort algorithm in DEscending order
     * @param nums the array of integers to be sorted
     */
    public static void selectionSortD(int nums[]) {
        int max;  // declare needed variables
   
        for (int i = 0; i < nums.length; i++) {//"For" Loop is used to repeat a specific block of code for Selection sort
            max = i;                    // Assume first element is max
            // loop though entire array after above value
            for (int j = i + 1; j < nums.length; j++) {//"For" Loop is used to repeat a specific block of code for Selection sort
                if (nums[j] > nums[max]) {// check if the current value is greater than the max value
                    max = j;  //set index of new max
                } // end if
                selectionC++;  //accumulate loop counter
            } // end for loop-2nd level j
            if (max != i) {// It is used to decide whether a certain statement or block of statements will be executed or not i.e if a certain
                // swaps higher value on right with a lower value on left
                int temp = nums[i];      //sets as holder for 1st level value
                nums[i] = nums[max];     //sets min value in array back a position
                nums[max] = temp;        //sets new max
            } // end if
        } // end for loop-1st level i
    } // end selectionSortD()
  
    /** 
     * Sorts an array of integers using Bubble Sort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     */
    public static void bubbleSortA(int nums[]) {
        boolean flag = true;    //set flag to true to begin first pass
        int j = 0;              //how much the end of the array has been sorted
        int temp;               //temporary holding variable
        while(flag){ // runs until a swap didn't occur during a loop through of entire array
            flag = false;       //set flag to false awaiting a possible swap
            j++;                //accumulate since each iteration the first and last values are sorted
            // run through the unsorted part of array
            for(int i = 0; i < nums.length - j; i++){//"For" Loop is used to repeat a specific block of code for bubble sort
                // check if the current value is greater than the next value
                if(nums[i] > nums[i+1]) {// check if the current value is greater than the next value
                    // swaps lower value on right with a higher value on left
                    temp = nums[i];//temp is a variable that contains one single element of that array in your loop
                    nums[i] = nums[i+1];//this code is for finding nums[i]
                    nums[i+1] = temp;//it makes nums[i] equals to temp
                    flag = true;            //shows a swap occurred  
                } 
                bubbleC++; //accumulate loop counter
            } 
        } 
    }
    /**
     * Sorts an array of integers using Bubble Sort algorithm in DEscending order
     * @param nums the array of integers to be sorted
     */
    public static void bubbleSortD(int nums[]) {
        boolean flag = true;    //set flag to true to begin first pass
        int j = 0;              //how much the end of the array has been sorted
        int temp;               //temporary holding variable
        // runs until a swap didn't occur during a loop through of entire array
        while(flag){//The while statement evaluates expression, which must return a boolean value. If the expression evaluates to true , the while statement executes the statement(s) in the while block. The while statement continues testing the expression and executing its block until the expression evaluates to false .
            flag = false;       //set flag to false awaiting a possible swap
            j++;                //accumulate since each iteration the first and last values are sorted
            // run through the unsorted part of array
            for(int i = 0; i < nums.length - j; i++){//"For" Loop is used to repeat a specific block of code for bubble sort
               
                if(nums[i] < nums[i+1]) {// check if the current value is greater than the next value
                    // swaps lower value on left with a higher value on right
                    temp = nums[i];//temp is a variable that contains one single element of that array in your loop
                    nums[i] = nums[i+1];//it makes nums[i] equals to nums[i+1]
                    nums[i+1] = temp;//it makes nums[i] equals to temp
                    flag = true;            //shows a swap occurred  
                } // end if
                bubbleC++;                  //accumulate loop counter
            } 
        } 
    } 

    /**
     * Sorts an array of integers using Insertion Sort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     */
    public static void insertionSortA(int nums[]) {
        int j, temp;    // declare needed variables
        // loop through entire array
        for(int i = 1; i < nums.length; i++) {//"For" Loop is used to repeat a specific block of code for insertion sort
            j = i - 1;  //sets j to index of i
            // loops until j is negative OR the value at index j is less than value at index i
            while(j >= 0 && nums[j] > nums[i]) {//The while statement evaluates expression, which must return a boolean value.
                // swaps lower value on right with a higher value on left
                temp = nums[i];     //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i = j;              //sets i to j, since j is on left side i
                j--;                //disipate j, moves backwards in array index
                insertionC++;       //accumulate loop counter
            } 
        } 
    } 
    /**
     * Sorts an array of integers using Insertion Sort algorithm in DEcending order
     * @param nums the array of integers to be sorted
     */
    public static void insertionSortD(int nums[]) {
        int j, temp;    // declare needed variables
        // loop through entire array
        for (int i = 1; i < nums.length; i++) {//"For" Loop is used to repeat a specific block of code for insertion sort
            j = i - 1;  //sets j to index of i-1
            // loops until j is negative OR the value at index j is greater than value at index i
            while (j >= 0 && nums[j] < nums[i] ) {//The while statement evaluates expression, which must return a boolean value.
                // swaps lower value on left with a higher value on right
                temp = nums[i];     //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i = j;              //sets i to j, since j is on left side i
                j--;                //disipate j, moves backwards in array index
                insertionC++;       //accumulate loop counter
            } 
        } 
    }

    /**
     * Sorts an array of integers using Quicksort algorithm in Ascending order
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     */
    public static void quicksortA(int nums[], int lowIndex, int highIndex) {
     
        if (lowIndex < highIndex) {//check if highIndex is greaater than lowIndex
            // q is the index of the pivot
            int q = partitionA(nums, lowIndex, highIndex);   //actually sorts values in array (sorts the pivot)
            quicksortA(nums, lowIndex, q);                  //recursive call to left half of pivot (inclusive)
            quicksortA(nums, q+1, highIndex);               //recursive call to right half of pivot (exclusive)
        } 
    } 
    /**
     * Sorts the pivot (for Ascending order)
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     * @return the index of the pivot
     */
    public static int partitionA(int nums[], int lowIndex, int highIndex) {
        // declare needed variables
        int x = nums[lowIndex]; //pivot's value
        int i = lowIndex;       //lowIndex
        int j = highIndex;      //highIndex
        // runs until value is returned when i > j
        while(true) {//The while statement evaluates expression, which must return a boolean value.
            // ignores all the numbers < x to left
            while (nums[i] < x) {//The while statement evaluates expression, which must return a boolean value.
                i++; //accumulate
                quickC++;           //accumulate loop counter
            }
            //ignore all numbers > x to right
            while (nums[j] > x) {//The while statement evaluates expression, which must return a boolean value.
                j--;//dissipate
                quickC++;           //accumulate loop counter
            }
            
            if (i < j) {// checks if i < j
                // swaps a value higher than x with a lower value right of x
                int temp = nums[i]; //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i++;                //accumulate
                j--;                //dissipate
            } else {// checks if i > j
                return j;//A return statement causes the program control to transfer back to the caller of a method.
            } // end if
       } // end while loop
    } // end partitionA()
    /**
     * Sorts an array of integers using Quicksort algorithm in DEscending order
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     */
    public static void quicksortD(int nums[], int lowIndex, int highIndex) {
        // checks if lowIndex < highIndex
        if (lowIndex < highIndex) {//check if highIndex is greaater than lowIndex
            // q is the index of the pivot
            int q = partitionD(nums, lowIndex, highIndex);  //actually sorts values in array (sorts the pivot)
            quicksortD(nums, lowIndex, q);                  //recursive call to left half of pivot (inclusive)
            quicksortD(nums, q+1, highIndex);               //recursive call to right half of pivot (exclusive)
        } 
    } 
    /**
     * Sorts the pivot (for DEscending order)
     * @param nums the array of integers to be sorted
     * @param lowIndex the lowest index of the segment of array
     * @param highIndex the highest index of the segment of array
     * @return the index of the pivot
     */
    public static int partitionD(int nums[], int lowIndex, int highIndex) {
        // declare needed variables
        int x = nums[lowIndex]; //pivot's value
        int i = lowIndex;       //lowIndex
        int j = highIndex;      //highIndex
        // runs until value is returned when i > j
        while(true) {//The while statement evaluates expression, which must return a boolean value.
            // ignores all the numbers > x to left
            while (nums[i] > x) {// checks if x < nums[i]
                i++;//accumulate
                quickC++;           //accumulate loop counter
            } 
            
            while (nums[j] < x) {// checks if x > nums[i]
                j--;//dissipate
                quickC++;           //accumulate loop counter
            } 
         
            if (i < j) {// checks if i < j
                // swaps a value lower than x with a higher value right of x
                int temp = nums[i]; //sets as holder for 1st level value
                nums[i] = nums[j];  //sets min value in array back a position
                nums[j] = temp;     //sets new min
                i++;                //accumulate
                j--;                //dissipate
            } else {// checks if i > j
                return j;//A return statement causes the program control to transfer back to the caller of a method.
            }
       } 
    } 
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnSort;
    private javax.swing.JComboBox cboSortType;
    private javax.swing.JButton exit;
    private javax.swing.ButtonGroup grpSortNum;
    private javax.swing.ButtonGroup grpSortOrder;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JLabel lblOriginal;
    private javax.swing.JLabel lblResults;
    private javax.swing.JLabel lblSortNum;
    private javax.swing.JLabel lblSortOrder;
    private javax.swing.JLabel lblSortType;
    private javax.swing.JLabel lblSorted;
    private javax.swing.JLabel lblTitle;
    private javax.swing.JButton print;
    private javax.swing.JButton print1;
    private javax.swing.JRadioButton rdo10;
    private javax.swing.JRadioButton rdo100;
    private javax.swing.JRadioButton rdo1000;
    private javax.swing.JRadioButton rdo5000;
    private javax.swing.JRadioButton rdoAscending;
    private javax.swing.JRadioButton rdoDescending;
    private javax.swing.JButton reset;
    private javax.swing.JTextArea txtAOriginal;
    private javax.swing.JTextArea txtAResults;
    private javax.swing.JTextArea txtASorted;
    // End of variables declaration//GEN-END:variables
} // end class
